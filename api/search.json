[{"id":"66106a844b05c7cccddac80b003e8081","title":"U370314 内存清理 总结","content":"内存清理题目描述小a经常使用他的手机，现在他的手机上正运行着  个应用程序，第  个应用程序占用  内存单元。现在他的手机有些卡顿，他希望能够让手机释放至少  个内存单元（通过终止一些应用程序）。\n但是，有些应用程序对小a来说比其他应用程序更加重要，现在他将应用程序的优先级分为两类：如果一个应用程序的优先级为  ，表示这是一个普通的程序；如果一个应用程序的优先级为  ，表示这是一个非常重要的应用程序。\n根据这个优先级系统，他的手机将有  分数。\n现在小a打算终止一些应用程序，这些应用程序的编号为  ，这样，他的手机将会释放  的内存，而且还会失去  的分数。\n请你帮助小a选择终止一些应用程序，使得他的手机能够至少释放  的内存，并且损失的分数最少；如果无法做到，则输出 。\n输入格式第一行一个正整数  表示数据组数。\n对于每一组数据，第一行两个整数  ，分别表示此时运行的应用程序的数量，以及至少释放的内存数。\n第二行包含  个整数，第  个数为  ，表示这个程序所占的内存数。\n第三行包含  个整数，第  个数为  ，表示这个程序的分数。\n输出格式输出包含  行，如果能够使得小a的手机释放至少  内存的方法，那么输出这些方法中损失分数最少的数量；如果不存在这样的方法，则输出  。\n样例 #1样例输入txt2\n5 7\n5 3 2 1 4\n2 1 1 2 1\n4 4\n1 1 2 1\n1 2 1 2样例输出txt2\n4解释\n对于第一组数据部分可选的方案如下：\n\n如果终止应用  ，那么将会释放  的内存，损失  的分数。\n如果终止应用  ，那么将会释放  的内存，损失  的分数。\n如果终止应用  ，那么将会释放  的内存，损失  的分数。\n…\n\n最终所有的情况下，最少损失的分数为  。\n对于第二组数据：\n终止应用  ，释放  的内存，损失  的分数。\nAnswer枚举+二分查找：\n\n初始化：cppans = 1e9, cnta = cntb = sum = 0;\n枚举 。如果 ，则：cppans = min(ans, i);\nbreak;  否则：cppint need = m - suma[i];\n二分查找满足 （）， 的最小值。\n如果  跳过。否则：cppans = min(ans, i + 2 * r);\n\n代码cpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\nnamespace rll { //Reduced linked list\n    template&lt;typename T, const unsigned int MAX_LENGTH&gt;\n    class stack\n    {\n    public:\n        unsigned int t = 0;\n        T s[MAX_LENGTH];\n        const T&amp; operator[](unsigned int x) const\n        {\n            if (x &gt;= t)\n                exit(11);\n            return s[x];\n        }\n        T&amp; operator[](unsigned int x)\n        {\n            if (x &gt;= t)\n                exit(11);\n            return s[x];\n        }\n        void push(T x)\n        {\n            s[t++] = x;\n            return;\n        }\n        T pop()\n        {\n            return s[--t];\n        }\n        T top()\n        {\n            return s[t - 1];\n        }\n        T find(unsigned int x)\n        {\n            if (x &gt;= t)\n                exit(11);\n            return s[t - 1 - x];\n        }\n        void clear()\n        {\n            delete this;\n        }\n        ~stack()\n        {\n            delete this;\n        }\n    };\n}\nconst int N = 10000005;\nint n, t, m, a[N], b[N], suma[N], sumb[N], ans, cnta, cntb, c[N], sum;\nbool cmp(int x, int y)\n{\n    return x &gt; y;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; t;\n    while (t--)\n    {\n        cin &gt;&gt; n &gt;&gt; m;\n        cnta = cntb = sum = 0;\n        ans = (int)(1e18);\n        for (int i = 1; i &lt;= n; i++)\n            cin &gt;&gt; c[i];\n        for (int i = 1; i &lt;= n; i++)\n        {\n            int x;\n            cin &gt;&gt; x;\n            sum += c[i];\n            if (x == 1)\n                a[++cnta] = c[i];\n            else if (x == 2)\n                b[++cntb] = c[i];\n        }\n        if (sum &lt; m)\n        {\n            cout &lt;&lt; \"-1\\n\";\n            continue;\n        }\n        sort(a + 1, a + 1 + cnta, cmp);\n        sort(b + 1, b + 1 + cntb, cmp);\n        for (int i = 1; i &lt;= cnta; i++)\n            suma[i] = suma[i - 1] + a[i];\n        for (int i = 1; i &lt;= cntb; i++)\n            sumb[i] = sumb[i - 1] + b[i];\n        sumb[cntb + 1] = sumb[cntb];\n        for (int i = 0; i &lt;= cnta; i++)\n        {\n            if (suma[i] &gt;= m)\n            {\n                ans = min(ans, i);\n                break;\n            }\n            int need = m - suma[i];\n            int l = 0, r = cntb + 1;\n            while (l + 1 &lt; r)\n            {\n                int mid = (l + r) / 2;\n                if (need &lt;= sumb[mid])\n                    r = mid;\n                else\n                    l = mid;\n            }\n            if (need &lt;= sumb[r])\n                ans = min(ans, i + 2 * r);\n        }\n        if (ans == (int)1e18)\n            ans = -1;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n    return 0;\n}","slug":"U370314 总结","date":"2023-11-29T13:13:00.000Z","categories_index":"总结","tags_index":"Post","author_index":"Wu Bangwei"},{"id":"51a863df1347b672344471e40260526e","title":"23-11-22 基础能力提升训练② 总结","content":"23-11-22 基础能力提升训练②\n\nE这道题和打击犯罪(black)一个逻辑，删除就是添加。\n注意！减少一个点，不是去掉与它连接的边，是删除这一个点。\n代码 大部分是注释和调试，代码其实很简短\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\n//namespace rll { //Reduced linked list\n//\ttemplate&lt;typename T, const unsigned int MAX_LENGTH&gt;\n//\tclass stack\n//\t{\n//\tpublic:\n//\t\tunsigned int t = 0;\n//\t\tT s[MAX_LENGTH];\n//\t\tconst T&amp; operator[](unsigned int x) const\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tT&amp; operator[](unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tvoid push(T x)\n//\t\t{\n//\t\t\ts[t++] = x;\n//\t\t\treturn;\n//\t\t}\n//\t\tT pop()\n//\t\t{\n//\t\t\treturn s[--t];\n//\t\t}\n//\t\tT top()\n//\t\t{\n//\t\t\treturn s[t - 1];\n//\t\t}\n//\t\tT find(unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[t - 1 - x];\n//\t\t}\n//\t\tvoid clear()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t\t~stack()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t};\nint n, m, fa[400005], b[400005], k, ans[400005], tot;\nbool vis[400005];\nint find(int x)\n{\n    if (fa[x] == x)\n        return x;\n    return fa[x] = find(fa[x]);\n}\nvoid unionn(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x != y)\n        fa[x] = y, tot--;\n    return;\n}\nvector&lt;int&gt;a[400005];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++)\n        fa[i] = i, vis[i] = true;\n    for (int i = 1; i &lt;= m; i++)\n    {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        x++, y++;\n        a[x].push_back(y);\n        a[y].push_back(x);\n    }\n    cin &gt;&gt; k;\n    for (int i = 1; i &lt;= k; i++)\n    {\n        cin &gt;&gt; b[i];\n        b[i]++;\n        vis[b[i]] = false;\n    }\n    tot = n;\n    for (int i = 1; i &lt;= n; i++)\n        for (auto j : a[i])\n            if (vis[j] &amp;&amp; vis[i])\n                unionn(j, i);\n    for (int i = k; i &gt;= 1; i--)\n    {\n        ans[i] = tot;\n        vis[b[i]] = true;\n        for (auto j : a[b[i]])\n            if (vis[j])\n                unionn(b[i], j);\n    }\n    cout &lt;&lt; tot &lt;&lt; \"\\n\";\n    for (int i = 1; i &lt;= k; i++)\n        cout &lt;&lt; ans[i] - i &lt;&lt; '\\n';\n    return 0;\n}F P4047 [JSOI2010] 部落划分并查集+最小生成树\n代码cpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\n//namespace rll { //Reduced linked list\n//\ttemplate&lt;typename T, const unsigned int MAX_LENGTH&gt;\n//\tclass stack\n//\t{\n//\tpublic:\n//\t\tunsigned int t = 0;\n//\t\tT s[MAX_LENGTH];\n//\t\tconst T&amp; operator[](unsigned int x) const\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tT&amp; operator[](unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tvoid push(T x)\n//\t\t{\n//\t\t\ts[t++] = x;\n//\t\t\treturn;\n//\t\t}\n//\t\tT pop()\n//\t\t{\n//\t\t\treturn s[--t];\n//\t\t}\n//\t\tT top()\n//\t\t{\n//\t\t\treturn s[t - 1];\n//\t\t}\n//\t\tT find(unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[t - 1 - x];\n//\t\t}\n//\t\tvoid clear()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t\t~stack()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t};\nint n, fa[1005], k, ans, cnt, tot, m[1005][1005];\nstruct node {\n    int x, y;\n    double z;\n}a[1000005], b[1005];\nbool cmp(node x, node y)\n{\n    return x.z &lt; y.z;\n}\n//----start----模板\nint find(int x)\n{\n    if (fa[x] == x)\n        return x;\n    return fa[x] = find(fa[x]);\n}\nvoid unionn(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x != y)\n        fa[x] = y;\n    return;\n}\n//----end----\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1; i &lt;= n; i++)\n        fa[i] = i, cin &gt;&gt; b[i].x &gt;&gt; b[i].y;\n    for (int i = 1; i &lt; n; i++)\n        for (int j = i + 1; j &lt;= n; j++)\n        {\n            a[++tot] = node{ i,j,sqrt(0.00 + (b[i].x - b[j].x) * (b[i].x - b[j].x) + (b[i].y - b[j].y) * (b[i].y - b[j].y)) };\n            m[i][j] = tot;\n        }\n    cnt = -1;\n    sort(a + 1, a + 1 + tot, cmp);\n    for (int i = 1; i &lt;= tot &amp;&amp; cnt + k &lt; n; i++)\n        if (find(a[i].x) != find(a[i].y))\n        {\n            unionn(a[i].x, a[i].y);\n            cnt++;\n            if (n - cnt &lt;= k)\n            {\n#if debug\n                cout &lt;&lt; \"\\tcnt=\" &lt;&lt; cnt &lt;&lt; \"\\ti=\" &lt;&lt; i &lt;&lt; \"\\n\";\n#endif\n                printf(\"%.2f\", a[i].z);\n                break;\n            }\n        }\n#if debug\n    cout &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; \"debug.fai\";\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= n; i++)\n        cout &lt;&lt; '\\t' &lt;&lt; i &lt;&lt; '\\t' &lt;&lt; find(i) &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; \"debug.x.y\";\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= n; i++)\n        cout &lt;&lt; '\\t' &lt;&lt; i &lt;&lt; '\\t' &lt;&lt; b[i].x &lt;&lt; '\\t' &lt;&lt; b[i].y &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; \" debug.z \";\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= tot; i++)\n        cout &lt;&lt; '\\t' &lt;&lt; a[i].x &lt;&lt; '\\t' &lt;&lt; a[i].y &lt;&lt; '\\t' &lt;&lt; a[i].z &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; \" debug.n \";\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; \"\\n\";\n    cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; k &lt;&lt; \" \" &lt;&lt; cnt &lt;&lt; \" \" &lt;&lt; n - cnt &lt;&lt; \"\\n\";\n#endif\n    return 0;\n}G P1265 公路修建Prim算法\n\nPrim 算法流程：\n开始将起点标记；\n找一条连接被标记的点集合中一点和没有被标记的点集合中一点最短的边；\n将该边连接的没有被标记的点加入被标记的点；\n将该新加入的被标记的点所有连接的没有被标记的点最短边更新；\n返回第二步，直到  个点都被选入最小生成树为止。\n\n\n\n代码cpp#include&lt;bits/stdc++.h&gt;\n#define debug false\ntypedef int iint;//其实根本没用\n#define int long long\nusing namespace std;\n//namespace rll { //Reduced linked list\n//\ttemplate&lt;typename T, const unsigned int MAX_LENGTH&gt;\n//\tclass stack\n//\t{\n//\tpublic:\n//\t\tunsigned int t = 0;\n//\t\tT s[MAX_LENGTH];\n//\t\tconst T&amp; operator[](unsigned int x) const\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tT&amp; operator[](unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tvoid push(T x)\n//\t\t{\n//\t\t\ts[t++] = x;\n//\t\t\treturn;\n//\t\t}\n//\t\tT pop()\n//\t\t{\n//\t\t\treturn s[--t];\n//\t\t}\n//\t\tT top()\n//\t\t{\n//\t\t\treturn s[t - 1];\n//\t\t}\n//\t\tT find(unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[t - 1 - x];\n//\t\t}\n//\t\tvoid clear()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t\t~stack()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t};\nint n/*, fa[5005]*/;//fa:并查集的父节点数组，在这里没用\nstruct node {\n    double x, y;\n}a[5005];\ndouble dis[5005], ans;\nbool vis[5005];\n//int find(int x)//并查集模板，在这里没用\n//{\n//\tif (fa[x] == x)\n//\t\treturn x;\n//\treturn fa[x] = find(fa[x]);\n//}\n//void unionn(int x, int y)\n//{\n//\tx = find(x);\n//\ty = find(y);\n//\tif (x != y)\n//\t\tfa[x] = y;\n//\treturn;\n//}\n\n//获取dis\ndouble get_dis(double x1, double y1, double x2, double y2)\n{\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        //fa[i] = i;//并查集初始化，在这里没用\n        dis[i] = 1e12;\n        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;\n    }\n    vis[1] = true;\n    dis[1] = 0.00;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        int curr = 1;\n        double mini = 1e9;\n        for (int j = 1; j &lt;= n; j++)\n            if (!vis[j] &amp;&amp; dis[j] &lt; mini)\n                curr = j, mini = dis[j];\n        ans += dis[curr];\n        vis[curr] = true;\n        for (int j = 1; j &lt;= n; j++)\n            dis[j] = min(dis[j], get_dis(a[curr].x, a[curr].y, a[j].x, a[j].y));\n    }\n    printf(\"%.2lf\", ans);\n    return 0;\n}","slug":"23-11-22 基础能力提升训练② 总结","date":"2023-11-29T13:13:00.000Z","categories_index":"总结","tags_index":"Post","author_index":"Wu Bangwei"},{"id":"ad416a109aaac48059715d5547ee3cee","title":"e-mail to me","content":"e-mail to me\n","slug":"Mailtome","date":"2023-11-29T12:21:22.036Z","categories_index":"","tags_index":"","author_index":"Wu Bangwei"},{"id":"c40f6896e2fc868cbe4fe3c1016323a8","title":"【个人总结】23-11-22 基础能力提升训练① 比赛总结","content":"23-11-22 基础能力提升训练①\n文章同载于CSDN\n\nD [CSP-J 2023] 公路今年（2023年）CSP-J T2，贪心。\n\n贪心思想：\n找到一个比当前选定更优的、在选定的右边的站点，在那里停下加油。\n\n\n\n\n代码：\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false //debug作为调试开关\n#define int long long\nusing namespace std;\nint n,d,v[100005],a[100005],ans,b,c;\ndouble s;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin&gt;&gt;n&gt;&gt;d;\n    if(n==1)\n    {\n        cout&lt;&lt;0;\n        return 0;\n    }\n    for(int i=1;i&lt;n;i++)\n        cin&gt;&gt;v[i];\n    for(int i=1;i&lt;=n;i++)\n        cin&gt;&gt;a[i];\n    b=v[1],c=1,s=0;\n    for(int i=2;i&lt;n;i++)\n    {\n        if(a[c]&gt;a[i])\n        {\n            if(s&lt;(1.00*b/d))\n            {\n                ans+=ceil(1.00*b/d-s)*a[c];\n#if debug\n                cout&lt;&lt;ans&lt;&lt;'\\n';\n#endif\n                s=ceil(1.00*b/d-s)-(1.00*b/d-s);\n                c=i;\n                b=0;\n            }\n            else\n            {\n                s-=(1.00*b/d);\n                b=0;\n                c=i;\n            }\n        }\n        b+=v[i];\n    }\n    if(s&lt;(1.00*b/d))\n        ans+=ceil(1.00*b/d-s)*a[c];\n    cout&lt;&lt;ans;\n    return 0;\n}E 修复公路可以使用并查集+二分/最小生成树。（比赛时用二分，忘记特判）\n代码：\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\nint n,m,fa[1005];\nstruct node{\n    int x,y,t;\n}a[100005];\nbool cmp(node x,node y)\n{\n    return x.t&lt;=y.t;\n}\nint find(int x)\n{\n    if(fa[x]==x)\n        return x;\n    return fa[x]=find(fa[x]);\n}\nvoid unionn(int x,int y)\n{\n    x=find(x);\n    y=find(y);\n    if(x!=y)\n        fa[x]=y;\n    return;\n}\nbool check(int mid)\n{\n    for(int i=1;i&lt;=n;i++)\n        fa[i]=i;\n    for(int i=1;i&lt;=m;i++)\n        if(a[i].t&lt;=mid)\n            unionn(a[i].x,a[i].y);\n        else\n            break;\n    int f=find(1);\n    for(int i=2;i&lt;=n;i++)\n        if(f!=find(i))\n            return false;\n    return true;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=m;i++)\n        cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].t;\n    sort(a+1,a+1+m,cmp);\n    int l=0,r=100001;\n    while(l+1&lt;r)\n    {\n        int mid=(l+r)/2;\n        if(check(mid))\n            r=mid;\n        else\n            l=mid;\n    }\n    if(!check(r))\n    {\n        cout&lt;&lt;-1;\n        return 0;\n    }\n    cout&lt;&lt;r;\n    return 0;\n}F 炸铁路只会写暴力，暴力不会超时。 （暴力+并查集 好写一些）\n代码：\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\nint n,m,fa[155];\nstruct node{\n    int x,y;\n}a[5005];\nint find(int x)\n{\n    if(fa[x]==x)\n        return x;\n    return fa[x]=find(fa[x]);\n}\nvoid unionn(int x,int y)\n{\n    x=find(x);\n    y=find(y);\n    if(x!=y)\n        fa[x]=y;\n    return;\n}\nbool check(int mid)\n{\n    for(int i=1;i&lt;=n;i++)\n        fa[i]=i;\n    for(int i=1;i&lt;=m;i++)\n        if(i!=mid)\n            unionn(a[i].x,a[i].y);\n    int f=find(1);\n    for(int i=2;i&lt;=n;i++)\n        if(f!=find(i))\n            return true;\n    return false;\n}\nbool cmp(node x,node y)\n{\n    if(x.x!=y.x)\n        return x.x&lt;y.x;\n    return x.y&lt;y.y;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=m;i++)\n    {\n        cin&gt;&gt;a[i].x&gt;&gt;a[i].y;\n        if(a[i].x&gt;a[i].y)\n            swap(a[i].x,a[i].y);\n    }\n    sort(a+1,a+1+m,cmp);\n    for(int i=1;i&lt;=m;i++)\n        if(check(i))\n            cout&lt;&lt;a[i].x&lt;&lt;\" \"&lt;&lt;a[i].y&lt;&lt;\"\\n\";\n    return 0;\n}作业题G 集合题目描述Caima 给你了所有  范围内的整数。一开始每个整数都属于各自的集合。每次你需要选择两个属于不同集合的整数，如果这两个整数拥有大于等于  的 公共质因数 ，那么把它们所在的集合合并。\n重复如上操作，直到没有可以合并的集合为止。\n现在 Caima 想知道，最后有多少个集合。\n答案并查集+素数筛（我用的是欧拉筛）。\n代码:\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\nint a, b, fa[100005], ans, p, c[100005], cnt;\nbool vis[100005];\nvoid init()\n{\n    for (int i = 2; i &lt;= b; i++)\n        vis[i] = true;\n    for (int i = 2; i &lt;= b; i++)\n        {\n            if (vis[i])\n                c[++cnt] = i;\n            for (int j = 1; j &lt;= cnt; j++)\n            {\n                if (i * c[j] &gt; b)\n                    break;\n                vis[i * c[j]] = false;\n                if (i % c[j] == 0)\n                    break;\n            }\n        }\n    return;\n}\nint find(int x)\n{\n    if (fa[x] == x)\n        return x;\n    return fa[x] = find(fa[x]);\n}\nvoid unionn(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x != y)\n    {\n        fa[x] = y;\n    }\n    return;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;\n    init();\n    for (int i = 1; i &lt;= b; i++)\n        fa[i] = i;\n    for (int i = p; i &lt;= b; i++)\n        if (vis[i])\n            for (int j = i * 2; j &lt;= b; j += i)\n            {\n                unionn(i, j);\n#if debug\n                cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" i j\\n\";\n#endif\n            }\n    for (int i = a; i &lt;= b; i++)\n        if (fa[i] == i)\n        {\n            ans++;\n#if debug\n            cout &lt;&lt; i &lt;&lt; '\\n';\n#endif\n        }\n#if debug\n        else\n        {\n            cout &lt;&lt; \"fa:\" &lt;&lt; find(i) &lt;&lt; \" i:\" &lt;&lt; i &lt;&lt; \"\\n\";\n        }\n#endif\n    cout &lt;&lt; ans;\n    return 0;\n}H 村村通本人使用并查集+最小生成树。\n代码：\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\nint n, m, fa[1005],cnt;\nint find(int x)\n{\n    if (fa[x] == x)\n        return x;\n    return fa[x] = find(fa[x]);\n}\nvoid unionn(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x != y)\n        fa[x] = y, cnt++;\n    return;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; n;\n    while (n != 0)\n    {\n        cin &gt;&gt; m;\n        for (int i = 1; i &lt;= n; i++)\n            fa[i] = i;\n        cnt = 0;\n        int x, y;\n        for (int i = 1; i &lt;= m; i++)\n            cin &gt;&gt; x &gt;&gt; y, unionn(x, y);\n        cout &lt;&lt; n - 1 - cnt &lt;&lt; '\\n';\n        cin &gt;&gt; n;\n    }\n    return 0;\n}","slug":"比赛总结1","date":"2023-11-27T13:03:10.000Z","categories_index":"总结","tags_index":"Post","author_index":"Wu Bangwei"},{"id":"9664945b0562f54f03173099af264118","title":"My New Post","content":"\n","slug":"My-New-Post","date":"2023-11-27T12:20:10.000Z","categories_index":"","tags_index":"Post","author_index":"Wu Bangwei"},{"id":"c0495d6ec17f90cd864f77d5bf12be8a","title":"temp1","content":"\n\nhello\n\n","slug":"temp1","date":"2023-11-27T12:10:58.085Z","categories_index":"","tags_index":"","author_index":"Wu Bangwei"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deployMore info: Deployment\n","slug":"hello-world","date":"2023-11-27T12:03:09.849Z","categories_index":"","tags_index":"","author_index":"Wu Bangwei"}]