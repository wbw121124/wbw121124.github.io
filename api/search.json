[{"id":"ed698b80a4ed647896206c94dc889942","title":"KMP算法","content":"KMP算法KMP算法是一个字符串算法，通常用于匹配字符串。\nKMP算法的原理如果我们暴力枚举下标 ， 是文本串的下标， 是模式串（你要在文本串中匹配的字符串）的下标，时间复杂度 ，其中  分别为文本串和模式串的长度。\n我们看一下匹配过程：（gif 动图请耐心观看）\n\n时间复杂度高吧，出题人随便就  掉了。\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n文本串\nx\ny\nx\ny\nx\ny\nx\ny\nx\nw\n\n\n模式串\nx\ny\nx\ny\nx\ny\nw\ny\n\n\n\n\n咦？我们会发现 文本串模式串模式串，这样我们  匹配失败时可以跳  次（），就可以达到正确性和时间复杂度平衡的效果。\n我们维护  表示s和s以i结尾的最长公共前后缀的长度，这样我们在 文本串模式串 匹配失败时  可以直接跳到 。\n维护 nxt[i]\n若  也就是 模式串模式串 匹配时，nxt[++i]=++j（其他同理写法也可以，最好固定一个写法），否则按文本串和模式串匹配失败来。\n代码cppvoid getNext(string s)//初始化和文本串没关系\n{\n    nxt[0] = -1;\n    int i = 0, j = -1;\n    while (i &lt; s.size())\n        if (j == -1 || s[i] == s[j])\n            nxt[++i] = ++j;\n        else\n            j = nxt[j];\n    return;\n}\nvoid KMP(string s, string t)//P3375的询问代码\n{\n    getNext(t);\n    int i = 0, j = 0;\n    while (i &lt; s.size())\n    {\n        if (j == t.size() - 1 &amp;&amp; s[i] == t[j])\n        {\n            cout &lt;&lt; i - j + 1 &lt;&lt; '\\n';\n            j = nxt[j];\n        }\n        if (j == -1 || s[i] == t[j])\n            i++, j++;\n        else\n            j = nxt[j];\n    }\n    return;\n}nxt 数组的性质\nnxt[i] 既表示以i结尾的最长公共前后缀的长度，又表示  失配时跳跃的位置；\nnxt[i] 越大，匹配的速度越慢，但至少移动  步；\n对于字符串 ，nxt[] 的最大下标 s.size()；\n\nKMP算法应用P3375 【模板】KMPP4391 [BOI2009] Radio Transmission 无线传输给你一个字符串 ，它是由某个字符串  不断自我连接形成的（保证至少重复  次）。但是字符串  是不确定的，现在只想知道它的最短长度是多少。\n不想说过程，直接说结论：ans = n - nxt[n]\nCF1200E Compress Wordscppcin &gt;&gt; n;\nfor (int i = 1; i &lt;= n; i++)\n{\n    cin &gt;&gt; s;\n    if (ans.empty())\n        ans = s;\n    else\n    {\n        int len = min(s.size(), ans.size());\n        string s1 = s.substr(0, len);\n        string s2 = ans.substr(ans.size() - len, len);\n        string s3 = s1 + \"#\" + s2;//中间必须拼上\"#\"，不然有可能最长公共前后缀重合。\n        getNext(s3);\n        ans += s.substr(nxt[s3.size()]);\n    }\n}\ncout &lt;&lt; ans;CF126B Password\n目标子串  一定是  的公共前后缀；\n求出 nxt[] 数组，并截取最长公共前后缀 ;\n在  范围内跑KMP，若找到 ，则 就是答案；\n若 nxt[nxt[n]] != -1，则  即为答案；\n\nP3435 [POI2006] OKR-Periods of Words\n根据画图推导，对于  的每一个前缀 ，要找  的最短公共前后缀；\n\ncppint find(int x)//最短公共前后缀\n{\n    if (nxt[x] &lt;= 0)\n        return x;\n    return nxt[x] = find(nxt[x]);\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; s;\n    getNext(s);\n    for (int i = 1; i &lt;= n; i++)\n        ans += i - find(i);\n    cout &lt;&lt; ans;\n    return 0;\n}P4824 [USACO15FEB] Censoring S\n删除  串之后产生的新的  串的起点一定在删除位置的左侧；\n后出现  串先处理，考虑用栈维护；\n栈中存储的下标维护已经匹配的  串的位数，match[i]；\n\ncpp//两种写法：\n//1\nvoid KMP(string s, string t)\n{\n    getNext(t);\n    int i = 0, j = 0;\n    while (i &lt; s.size())\n    {\n        /*if (j == t.size() - 1 &amp;&amp; s[i] == t[j])\n        {\n            cout &lt;&lt; i - j + 1 &lt;&lt; '\\n';\n            j = nxt[j];\n        }*/\n        if (j == -1 || s[i] == t[j])\n        {\n            st.push_back({ s[i],j + 1 });\n            i++, j++;\n        }\n        else\n            j = nxt[j];\n        if (j == t.size())\n        {\n            for (int i = 1; i &lt;= t.size(); i++)\n                st.pop_back();\n            j = st.back().second;\n        }\n    }\n    return;\n}\n//2\nvoid KMP(string s, string t)\n{\n    getNext(t);\n    int i = 0, j = 0;\n    while (i &lt; s.size())\n    {\n        if (j == t.size() - 1 &amp;&amp; s[i] == t[j])\n        {\n            i++;\n            for (int i = 1; i &lt; t.size(); i++)\n                st.pop_back();\n            j = st.back().second;\n            continue;\n        }\n        if (j == -1 || s[i] == t[j])\n        {\n            st.push_back({ s[i],j + 1 });\n            i++, j++;\n        }\n        else\n            j = nxt[j];\n    }\n    return;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; s &gt;&gt; t;\n    KMP(s, t);\n    for (auto&amp; [x, y] : st)\n        cout &lt;&lt; x;\n    return 0;\n}P4591 [TJOI2018] 碱基序列截止  年  月  日，此题难度 $\\color\n","slug":"KMP算法","date":"2024-10-11T13:00:00.000Z","categories_index":"算法","tags_index":"Post 算法 KMP","author_index":"Wu Bangwei"},{"id":"66106a844b05c7cccddac80b003e8081","title":"U370314 内存清理 总结","content":"内存清理题目描述小a经常使用他的手机，现在他的手机上正运行着  个应用程序，第  个应用程序占用  内存单元。现在他的手机有些卡顿，他希望能够让手机释放至少  个内存单元（通过终止一些应用程序）。\n但是，有些应用程序对小a来说比其他应用程序更加重要，现在他将应用程序的优先级分为两类：如果一个应用程序的优先级为  ，表示这是一个普通的程序；如果一个应用程序的优先级为  ，表示这是一个非常重要的应用程序。\n根据这个优先级系统，他的手机将有  分数。\n现在小a打算终止一些应用程序，这些应用程序的编号为  ，这样，他的手机将会释放  的内存，而且还会失去  的分数。\n请你帮助小a选择终止一些应用程序，使得他的手机能够至少释放  的内存，并且损失的分数最少；如果无法做到，则输出 。\n输入格式第一行一个正整数  表示数据组数。\n对于每一组数据，第一行两个整数  ，分别表示此时运行的应用程序的数量，以及至少释放的内存数。\n第二行包含  个整数，第  个数为  ，表示这个程序所占的内存数。\n第三行包含  个整数，第  个数为  ，表示这个程序的分数。\n输出格式输出包含  行，如果能够使得小a的手机释放至少  内存的方法，那么输出这些方法中损失分数最少的数量；如果不存在这样的方法，则输出  。\n样例 #1样例输入txt2\n5 7\n5 3 2 1 4\n2 1 1 2 1\n4 4\n1 1 2 1\n1 2 1 2样例输出txt2\n4解释\n对于第一组数据部分可选的方案如下：\n\n如果终止应用  ，那么将会释放  的内存，损失  的分数。\n如果终止应用  ，那么将会释放  的内存，损失  的分数。\n如果终止应用  ，那么将会释放  的内存，损失  的分数。\n…\n\n最终所有的情况下，最少损失的分数为  。\n对于第二组数据：\n终止应用  ，释放  的内存，损失  的分数。\nAnswer枚举+二分查找：\n\n初始化：cppans = 1e9, cnta = cntb = sum = 0;\n枚举 。如果 ，则：cppans = min(ans, i);\nbreak;  否则：cppint need = m - suma[i];\n二分查找满足 （）， 的最小值。\n如果  跳过。否则：cppans = min(ans, i + 2 * r);\n\n代码cpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\nnamespace rll { //Reduced linked list\n    template&lt;typename T, const unsigned int MAX_LENGTH&gt;\n    class stack\n    {\n    public:\n        unsigned int t = 0;\n        T s[MAX_LENGTH];\n        const T&amp; operator[](unsigned int x) const\n        {\n            if (x &gt;= t)\n                exit(11);\n            return s[x];\n        }\n        T&amp; operator[](unsigned int x)\n        {\n            if (x &gt;= t)\n                exit(11);\n            return s[x];\n        }\n        void push(T x)\n        {\n            s[t++] = x;\n            return;\n        }\n        T pop()\n        {\n            return s[--t];\n        }\n        T top()\n        {\n            return s[t - 1];\n        }\n        T find(unsigned int x)\n        {\n            if (x &gt;= t)\n                exit(11);\n            return s[t - 1 - x];\n        }\n        void clear()\n        {\n            delete this;\n        }\n        ~stack()\n        {\n            delete this;\n        }\n    };\n}\nconst int N = 10000005;\nint n, t, m, a[N], b[N], suma[N], sumb[N], ans, cnta, cntb, c[N], sum;\nbool cmp(int x, int y)\n{\n    return x &gt; y;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; t;\n    while (t--)\n    {\n        cin &gt;&gt; n &gt;&gt; m;\n        cnta = cntb = sum = 0;\n        ans = (int)(1e18);\n        for (int i = 1; i &lt;= n; i++)\n            cin &gt;&gt; c[i];\n        for (int i = 1; i &lt;= n; i++)\n        {\n            int x;\n            cin &gt;&gt; x;\n            sum += c[i];\n            if (x == 1)\n                a[++cnta] = c[i];\n            else if (x == 2)\n                b[++cntb] = c[i];\n        }\n        if (sum &lt; m)\n        {\n            cout &lt;&lt; \"-1\\n\";\n            continue;\n        }\n        sort(a + 1, a + 1 + cnta, cmp);\n        sort(b + 1, b + 1 + cntb, cmp);\n        for (int i = 1; i &lt;= cnta; i++)\n            suma[i] = suma[i - 1] + a[i];\n        for (int i = 1; i &lt;= cntb; i++)\n            sumb[i] = sumb[i - 1] + b[i];\n        sumb[cntb + 1] = sumb[cntb];\n        for (int i = 0; i &lt;= cnta; i++)\n        {\n            if (suma[i] &gt;= m)\n            {\n                ans = min(ans, i);\n                break;\n            }\n            int need = m - suma[i];\n            int l = 0, r = cntb + 1;\n            while (l + 1 &lt; r)\n            {\n                int mid = (l + r) / 2;\n                if (need &lt;= sumb[mid])\n                    r = mid;\n                else\n                    l = mid;\n            }\n            if (need &lt;= sumb[r])\n                ans = min(ans, i + 2 * r);\n        }\n        if (ans == (int)1e18)\n            ans = -1;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n    return 0;\n}","slug":"U370314 总结","date":"2023-11-29T13:13:00.000Z","categories_index":"总结","tags_index":"Post","author_index":"Wu Bangwei"},{"id":"51a863df1347b672344471e40260526e","title":"23-11-22 基础能力提升训练② 总结","content":"23-11-22 基础能力提升训练②\n\nE这道题和打击犯罪(black)一个逻辑，删除就是添加。\n注意！减少一个点，不是去掉与它连接的边，是删除这一个点。\n代码 大部分是注释和调试，代码其实很简短\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\n//namespace rll { //Reduced linked list\n//\ttemplate&lt;typename T, const unsigned int MAX_LENGTH&gt;\n//\tclass stack\n//\t{\n//\tpublic:\n//\t\tunsigned int t = 0;\n//\t\tT s[MAX_LENGTH];\n//\t\tconst T&amp; operator[](unsigned int x) const\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tT&amp; operator[](unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tvoid push(T x)\n//\t\t{\n//\t\t\ts[t++] = x;\n//\t\t\treturn;\n//\t\t}\n//\t\tT pop()\n//\t\t{\n//\t\t\treturn s[--t];\n//\t\t}\n//\t\tT top()\n//\t\t{\n//\t\t\treturn s[t - 1];\n//\t\t}\n//\t\tT find(unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[t - 1 - x];\n//\t\t}\n//\t\tvoid clear()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t\t~stack()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t};\nint n, m, fa[400005], b[400005], k, ans[400005], tot;\nbool vis[400005];\nint find(int x)\n{\n    if (fa[x] == x)\n        return x;\n    return fa[x] = find(fa[x]);\n}\nvoid unionn(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x != y)\n        fa[x] = y, tot--;\n    return;\n}\nvector&lt;int&gt;a[400005];\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++)\n        fa[i] = i, vis[i] = true;\n    for (int i = 1; i &lt;= m; i++)\n    {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        x++, y++;\n        a[x].push_back(y);\n        a[y].push_back(x);\n    }\n    cin &gt;&gt; k;\n    for (int i = 1; i &lt;= k; i++)\n    {\n        cin &gt;&gt; b[i];\n        b[i]++;\n        vis[b[i]] = false;\n    }\n    tot = n;\n    for (int i = 1; i &lt;= n; i++)\n        for (auto j : a[i])\n            if (vis[j] &amp;&amp; vis[i])\n                unionn(j, i);\n    for (int i = k; i &gt;= 1; i--)\n    {\n        ans[i] = tot;\n        vis[b[i]] = true;\n        for (auto j : a[b[i]])\n            if (vis[j])\n                unionn(b[i], j);\n    }\n    cout &lt;&lt; tot &lt;&lt; \"\\n\";\n    for (int i = 1; i &lt;= k; i++)\n        cout &lt;&lt; ans[i] - i &lt;&lt; '\\n';\n    return 0;\n}F P4047 [JSOI2010] 部落划分并查集+最小生成树\n代码cpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\n//namespace rll { //Reduced linked list\n//\ttemplate&lt;typename T, const unsigned int MAX_LENGTH&gt;\n//\tclass stack\n//\t{\n//\tpublic:\n//\t\tunsigned int t = 0;\n//\t\tT s[MAX_LENGTH];\n//\t\tconst T&amp; operator[](unsigned int x) const\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tT&amp; operator[](unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tvoid push(T x)\n//\t\t{\n//\t\t\ts[t++] = x;\n//\t\t\treturn;\n//\t\t}\n//\t\tT pop()\n//\t\t{\n//\t\t\treturn s[--t];\n//\t\t}\n//\t\tT top()\n//\t\t{\n//\t\t\treturn s[t - 1];\n//\t\t}\n//\t\tT find(unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[t - 1 - x];\n//\t\t}\n//\t\tvoid clear()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t\t~stack()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t};\nint n, fa[1005], k, ans, cnt, tot, m[1005][1005];\nstruct node {\n    int x, y;\n    double z;\n}a[1000005], b[1005];\nbool cmp(node x, node y)\n{\n    return x.z &lt; y.z;\n}\n//----start----模板\nint find(int x)\n{\n    if (fa[x] == x)\n        return x;\n    return fa[x] = find(fa[x]);\n}\nvoid unionn(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x != y)\n        fa[x] = y;\n    return;\n}\n//----end----\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1; i &lt;= n; i++)\n        fa[i] = i, cin &gt;&gt; b[i].x &gt;&gt; b[i].y;\n    for (int i = 1; i &lt; n; i++)\n        for (int j = i + 1; j &lt;= n; j++)\n        {\n            a[++tot] = node{ i,j,sqrt(0.00 + (b[i].x - b[j].x) * (b[i].x - b[j].x) + (b[i].y - b[j].y) * (b[i].y - b[j].y)) };\n            m[i][j] = tot;\n        }\n    cnt = -1;\n    sort(a + 1, a + 1 + tot, cmp);\n    for (int i = 1; i &lt;= tot &amp;&amp; cnt + k &lt; n; i++)\n        if (find(a[i].x) != find(a[i].y))\n        {\n            unionn(a[i].x, a[i].y);\n            cnt++;\n            if (n - cnt &lt;= k)\n            {\n#if debug\n                cout &lt;&lt; \"\\tcnt=\" &lt;&lt; cnt &lt;&lt; \"\\ti=\" &lt;&lt; i &lt;&lt; \"\\n\";\n#endif\n                printf(\"%.2f\", a[i].z);\n                break;\n            }\n        }\n#if debug\n    cout &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; \"debug.fai\";\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= n; i++)\n        cout &lt;&lt; '\\t' &lt;&lt; i &lt;&lt; '\\t' &lt;&lt; find(i) &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; \"debug.x.y\";\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= n; i++)\n        cout &lt;&lt; '\\t' &lt;&lt; i &lt;&lt; '\\t' &lt;&lt; b[i].x &lt;&lt; '\\t' &lt;&lt; b[i].y &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; \" debug.z \";\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= tot; i++)\n        cout &lt;&lt; '\\t' &lt;&lt; a[i].x &lt;&lt; '\\t' &lt;&lt; a[i].y &lt;&lt; '\\t' &lt;&lt; a[i].z &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; \" debug.n \";\n    for (int i = 1; i &lt;= 4; i++)\n        cout &lt;&lt; \"----\";\n    cout &lt;&lt; \"\\n\";\n    cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; k &lt;&lt; \" \" &lt;&lt; cnt &lt;&lt; \" \" &lt;&lt; n - cnt &lt;&lt; \"\\n\";\n#endif\n    return 0;\n}G P1265 公路修建Prim算法\n\nPrim 算法流程：\n开始将起点标记；\n找一条连接被标记的点集合中一点和没有被标记的点集合中一点最短的边；\n将该边连接的没有被标记的点加入被标记的点；\n将该新加入的被标记的点所有连接的没有被标记的点最短边更新；\n返回第二步，直到  个点都被选入最小生成树为止。\n\n\n\n代码cpp#include&lt;bits/stdc++.h&gt;\n#define debug false\ntypedef int iint;//其实根本没用\n#define int long long\nusing namespace std;\n//namespace rll { //Reduced linked list\n//\ttemplate&lt;typename T, const unsigned int MAX_LENGTH&gt;\n//\tclass stack\n//\t{\n//\tpublic:\n//\t\tunsigned int t = 0;\n//\t\tT s[MAX_LENGTH];\n//\t\tconst T&amp; operator[](unsigned int x) const\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tT&amp; operator[](unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[x];\n//\t\t}\n//\t\tvoid push(T x)\n//\t\t{\n//\t\t\ts[t++] = x;\n//\t\t\treturn;\n//\t\t}\n//\t\tT pop()\n//\t\t{\n//\t\t\treturn s[--t];\n//\t\t}\n//\t\tT top()\n//\t\t{\n//\t\t\treturn s[t - 1];\n//\t\t}\n//\t\tT find(unsigned int x)\n//\t\t{\n//\t\t\tif (x &gt;= t)\n//\t\t\t\texit(11);\n//\t\t\treturn s[t - 1 - x];\n//\t\t}\n//\t\tvoid clear()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t\t~stack()\n//\t\t{\n//\t\t\tdelete this;\n//\t\t}\n//\t};\nint n/*, fa[5005]*/;//fa:并查集的父节点数组，在这里没用\nstruct node {\n    double x, y;\n}a[5005];\ndouble dis[5005], ans;\nbool vis[5005];\n//int find(int x)//并查集模板，在这里没用\n//{\n//\tif (fa[x] == x)\n//\t\treturn x;\n//\treturn fa[x] = find(fa[x]);\n//}\n//void unionn(int x, int y)\n//{\n//\tx = find(x);\n//\ty = find(y);\n//\tif (x != y)\n//\t\tfa[x] = y;\n//\treturn;\n//}\n\n//获取dis\ndouble get_dis(double x1, double y1, double x2, double y2)\n{\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        //fa[i] = i;//并查集初始化，在这里没用\n        dis[i] = 1e12;\n        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;\n    }\n    vis[1] = true;\n    dis[1] = 0.00;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        int curr = 1;\n        double mini = 1e9;\n        for (int j = 1; j &lt;= n; j++)\n            if (!vis[j] &amp;&amp; dis[j] &lt; mini)\n                curr = j, mini = dis[j];\n        ans += dis[curr];\n        vis[curr] = true;\n        for (int j = 1; j &lt;= n; j++)\n            dis[j] = min(dis[j], get_dis(a[curr].x, a[curr].y, a[j].x, a[j].y));\n    }\n    printf(\"%.2lf\", ans);\n    return 0;\n}","slug":"23-11-22 基础能力提升训练② 总结","date":"2023-11-29T13:13:00.000Z","categories_index":"总结","tags_index":"Post","author_index":"Wu Bangwei"},{"id":"ad416a109aaac48059715d5547ee3cee","title":"e-mail to me","content":"e-mail to me\n","slug":"Mailtome","date":"2023-11-29T12:21:22.036Z","categories_index":"","tags_index":"","author_index":"Wu Bangwei"},{"id":"c40f6896e2fc868cbe4fe3c1016323a8","title":"【个人总结】23-11-22 基础能力提升训练① 比赛总结","content":"23-11-22 基础能力提升训练①\n文章同载于CSDN\n\nD [CSP-J 2023] 公路今年（2023年）CSP-J T2，贪心。\n\n贪心思想：\n找到一个比当前选定更优的、在选定的右边的站点，在那里停下加油。\n\n\n\n\n代码：\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false //debug作为调试开关\n#define int long long\nusing namespace std;\nint n,d,v[100005],a[100005],ans,b,c;\ndouble s;\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin&gt;&gt;n&gt;&gt;d;\n    if(n==1)\n    {\n        cout&lt;&lt;0;\n        return 0;\n    }\n    for(int i=1;i&lt;n;i++)\n        cin&gt;&gt;v[i];\n    for(int i=1;i&lt;=n;i++)\n        cin&gt;&gt;a[i];\n    b=v[1],c=1,s=0;\n    for(int i=2;i&lt;n;i++)\n    {\n        if(a[c]&gt;a[i])\n        {\n            if(s&lt;(1.00*b/d))\n            {\n                ans+=ceil(1.00*b/d-s)*a[c];\n#if debug\n                cout&lt;&lt;ans&lt;&lt;'\\n';\n#endif\n                s=ceil(1.00*b/d-s)-(1.00*b/d-s);\n                c=i;\n                b=0;\n            }\n            else\n            {\n                s-=(1.00*b/d);\n                b=0;\n                c=i;\n            }\n        }\n        b+=v[i];\n    }\n    if(s&lt;(1.00*b/d))\n        ans+=ceil(1.00*b/d-s)*a[c];\n    cout&lt;&lt;ans;\n    return 0;\n}E 修复公路可以使用并查集+二分/最小生成树。（比赛时用二分，忘记特判）\n代码：\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\nint n,m,fa[1005];\nstruct node{\n    int x,y,t;\n}a[100005];\nbool cmp(node x,node y)\n{\n    return x.t&lt;=y.t;\n}\nint find(int x)\n{\n    if(fa[x]==x)\n        return x;\n    return fa[x]=find(fa[x]);\n}\nvoid unionn(int x,int y)\n{\n    x=find(x);\n    y=find(y);\n    if(x!=y)\n        fa[x]=y;\n    return;\n}\nbool check(int mid)\n{\n    for(int i=1;i&lt;=n;i++)\n        fa[i]=i;\n    for(int i=1;i&lt;=m;i++)\n        if(a[i].t&lt;=mid)\n            unionn(a[i].x,a[i].y);\n        else\n            break;\n    int f=find(1);\n    for(int i=2;i&lt;=n;i++)\n        if(f!=find(i))\n            return false;\n    return true;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=m;i++)\n        cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].t;\n    sort(a+1,a+1+m,cmp);\n    int l=0,r=100001;\n    while(l+1&lt;r)\n    {\n        int mid=(l+r)/2;\n        if(check(mid))\n            r=mid;\n        else\n            l=mid;\n    }\n    if(!check(r))\n    {\n        cout&lt;&lt;-1;\n        return 0;\n    }\n    cout&lt;&lt;r;\n    return 0;\n}F 炸铁路只会写暴力，暴力不会超时。 （暴力+并查集 好写一些）\n代码：\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\nint n,m,fa[155];\nstruct node{\n    int x,y;\n}a[5005];\nint find(int x)\n{\n    if(fa[x]==x)\n        return x;\n    return fa[x]=find(fa[x]);\n}\nvoid unionn(int x,int y)\n{\n    x=find(x);\n    y=find(y);\n    if(x!=y)\n        fa[x]=y;\n    return;\n}\nbool check(int mid)\n{\n    for(int i=1;i&lt;=n;i++)\n        fa[i]=i;\n    for(int i=1;i&lt;=m;i++)\n        if(i!=mid)\n            unionn(a[i].x,a[i].y);\n    int f=find(1);\n    for(int i=2;i&lt;=n;i++)\n        if(f!=find(i))\n            return true;\n    return false;\n}\nbool cmp(node x,node y)\n{\n    if(x.x!=y.x)\n        return x.x&lt;y.x;\n    return x.y&lt;y.y;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=m;i++)\n    {\n        cin&gt;&gt;a[i].x&gt;&gt;a[i].y;\n        if(a[i].x&gt;a[i].y)\n            swap(a[i].x,a[i].y);\n    }\n    sort(a+1,a+1+m,cmp);\n    for(int i=1;i&lt;=m;i++)\n        if(check(i))\n            cout&lt;&lt;a[i].x&lt;&lt;\" \"&lt;&lt;a[i].y&lt;&lt;\"\\n\";\n    return 0;\n}作业题G 集合题目描述Caima 给你了所有  范围内的整数。一开始每个整数都属于各自的集合。每次你需要选择两个属于不同集合的整数，如果这两个整数拥有大于等于  的 公共质因数 ，那么把它们所在的集合合并。\n重复如上操作，直到没有可以合并的集合为止。\n现在 Caima 想知道，最后有多少个集合。\n答案并查集+素数筛（我用的是欧拉筛）。\n代码:\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\nint a, b, fa[100005], ans, p, c[100005], cnt;\nbool vis[100005];\nvoid init()\n{\n    for (int i = 2; i &lt;= b; i++)\n        vis[i] = true;\n    for (int i = 2; i &lt;= b; i++)\n        {\n            if (vis[i])\n                c[++cnt] = i;\n            for (int j = 1; j &lt;= cnt; j++)\n            {\n                if (i * c[j] &gt; b)\n                    break;\n                vis[i * c[j]] = false;\n                if (i % c[j] == 0)\n                    break;\n            }\n        }\n    return;\n}\nint find(int x)\n{\n    if (fa[x] == x)\n        return x;\n    return fa[x] = find(fa[x]);\n}\nvoid unionn(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x != y)\n    {\n        fa[x] = y;\n    }\n    return;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;\n    init();\n    for (int i = 1; i &lt;= b; i++)\n        fa[i] = i;\n    for (int i = p; i &lt;= b; i++)\n        if (vis[i])\n            for (int j = i * 2; j &lt;= b; j += i)\n            {\n                unionn(i, j);\n#if debug\n                cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" i j\\n\";\n#endif\n            }\n    for (int i = a; i &lt;= b; i++)\n        if (fa[i] == i)\n        {\n            ans++;\n#if debug\n            cout &lt;&lt; i &lt;&lt; '\\n';\n#endif\n        }\n#if debug\n        else\n        {\n            cout &lt;&lt; \"fa:\" &lt;&lt; find(i) &lt;&lt; \" i:\" &lt;&lt; i &lt;&lt; \"\\n\";\n        }\n#endif\n    cout &lt;&lt; ans;\n    return 0;\n}H 村村通本人使用并查集+最小生成树。\n代码：\ncpp#include&lt;bits/stdc++.h&gt;\n#define debug false\n#define int long long\nusing namespace std;\nint n, m, fa[1005],cnt;\nint find(int x)\n{\n    if (fa[x] == x)\n        return x;\n    return fa[x] = find(fa[x]);\n}\nvoid unionn(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x != y)\n        fa[x] = y, cnt++;\n    return;\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cin &gt;&gt; n;\n    while (n != 0)\n    {\n        cin &gt;&gt; m;\n        for (int i = 1; i &lt;= n; i++)\n            fa[i] = i;\n        cnt = 0;\n        int x, y;\n        for (int i = 1; i &lt;= m; i++)\n            cin &gt;&gt; x &gt;&gt; y, unionn(x, y);\n        cout &lt;&lt; n - 1 - cnt &lt;&lt; '\\n';\n        cin &gt;&gt; n;\n    }\n    return 0;\n}","slug":"比赛总结1","date":"2023-11-27T13:03:10.000Z","categories_index":"总结","tags_index":"Post","author_index":"Wu Bangwei"},{"id":"9664945b0562f54f03173099af264118","title":"My New Post","content":"\n","slug":"My-New-Post","date":"2023-11-27T12:20:10.000Z","categories_index":"","tags_index":"Post","author_index":"Wu Bangwei"},{"id":"c0495d6ec17f90cd864f77d5bf12be8a","title":"temp1","content":"\n\nhello\n\n","slug":"temp1","date":"2023-11-27T12:10:58.085Z","categories_index":"","tags_index":"","author_index":"Wu Bangwei"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deployMore info: Deployment\n","slug":"hello-world","date":"2023-11-27T12:03:09.849Z","categories_index":"","tags_index":"","author_index":"Wu Bangwei"}]